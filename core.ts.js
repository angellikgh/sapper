'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var fs = require('fs');
var __chunk1_js = require('./chunk1.js');
var path = require('path');
var mkdirp = _interopDefault(require('mkdirp'));
var glob = _interopDefault(require('glob'));
var relative = _interopDefault(require('require-relative'));

function write(file, code) {
    fs.writeFileSync(file, code);
    fudge_mtime(file);
}
function posixify(file) {
    return file.replace(/[/\\]/g, '/');
}
function fudge_mtime(file) {
    // need to fudge the mtime so that webpack doesn't go doolally
    var _a = fs.statSync(file), atime = _a.atime, mtime = _a.mtime;
    fs.utimesSync(file, new Date(atime.getTime() - 999999), new Date(mtime.getTime() - 999999));
}

// in dev mode, we avoid touching the fs unnecessarily
var last_client_manifest = null;
var last_server_manifest = null;
function create_app(_a) {
    var routes = _a.routes, dev_port = _a.dev_port;
    mkdirp.sync('app/manifest');
    var client_manifest = generate_client(routes, dev_port);
    var server_manifest = generate_server(routes);
    if (client_manifest !== last_client_manifest) {
        write("app/manifest/client.js", client_manifest);
        last_client_manifest = client_manifest;
    }
    if (server_manifest !== last_server_manifest) {
        write("app/manifest/server.js", server_manifest);
        last_server_manifest = server_manifest;
    }
}
function generate_client(routes, dev_port) {
    var code = ("\n\t\t// This file is generated by Sapper \u2014 do not edit it!\n\t\texport const routes = [\n\t\t\t" + routes
        .map(function (route) {
        if (route.type !== 'page') {
            return "{ pattern: " + route.pattern + ", ignore: true }";
        }
        var file = posixify("../../routes/" + route.file);
        if (route.id === '_4xx' || route.id === '_5xx') {
            return "{ error: '" + route.id.slice(1) + "', load: () => import(/* webpackChunkName: \"" + route.id + "\" */ '" + file + "') }";
        }
        var params = route.params.length === 0
            ? '{}'
            : "{ " + route.params.map(function (part, i) { return part + ": match[" + (i + 1) + "]"; }).join(', ') + " }";
        return "{ pattern: " + route.pattern + ", params: " + (route.params.length > 0 ? "match" : "()") + " => (" + params + "), load: () => import(/* webpackChunkName: \"" + route.id + "\" */ '" + file + "') }";
    })
        .join(',\n\t') + "\n\t\t];").replace(/^\t\t/gm, '').trim();
    if (__chunk1_js.dev()) {
        var sapper_dev_client = posixify(path.resolve(__dirname, 'sapper-dev-client.js'));
        code += ("\n\n\t\t\tif (module.hot) {\n\t\t\t\timport('" + sapper_dev_client + "').then(client => {\n\t\t\t\t\tclient.connect(" + dev_port + ");\n\t\t\t\t});\n\t\t\t}").replace(/^\t{3}/gm, '');
    }
    return code;
}
function generate_server(routes) {
    var code = ("\n\t\t// This file is generated by Sapper \u2014 do not edit it!\n\t\t" + routes
        .map(function (route) {
        var file = posixify("../../routes/" + route.file);
        return route.type === 'page'
            ? "import " + route.id + " from '" + file + "';"
            : "import * as " + route.id + " from '" + file + "';";
    })
        .join('\n') + "\n\n\t\texport const routes = [\n\t\t\t" + routes
        .map(function (route) {
        var file = posixify("../../" + route.file);
        if (route.id === '_4xx' || route.id === '_5xx') {
            return "{ error: '" + route.id.slice(1) + "', module: " + route.id + " }";
        }
        var params = route.params.length === 0
            ? '{}'
            : "{ " + route.params.map(function (part, i) { return part + ": match[" + (i + 1) + "]"; }).join(', ') + " }";
        return "{ id: '" + route.id + "', type: '" + route.type + "', pattern: " + route.pattern + ", params: " + (route.params.length > 0 ? "match" : "()") + " => (" + params + "), module: " + route.id + " }";
    })
        .join(',\n\t') + "\n\t\t];").replace(/^\t\t/gm, '').trim();
    return code;
}

function create_serviceworker(_a) {
    var routes = _a.routes, client_files = _a.client_files;
    var assets = glob.sync('**', { cwd: 'assets', nodir: true });
    var code = ("\n\t\t// This file is generated by Sapper \u2014 do not edit it!\n\t\texport const timestamp = " + Date.now() + ";\n\n\t\texport const assets = [\n\t" + assets.map(function (x) { return "\"" + x + "\""; }).join(',\n\t') + "\n];\n\n\t\texport const shell = [\n\t" + client_files.map(function (x) { return "\"" + x + "\""; }).join(',\n\t') + "\n];\n\n\t\texport const routes = [\n\t" + routes.filter(function (r) { return r.type === 'page' && !/^_[45]xx$/.test(r.id); }).map(function (r) { return "{ pattern: " + r.pattern + " }"; }).join(',\n\t') + "\n];\n\t").replace(/^\t\t/gm, '').trim();
    write('app/manifest/service-worker.js', code);
}

function create_compilers() {
    var webpack = relative('webpack', process.cwd());
    var serviceworker_config = try_require(path.resolve('webpack/service-worker.config.js'));
    return {
        client: webpack(require(path.resolve('webpack/client.config.js'))),
        server: webpack(require(path.resolve('webpack/server.config.js'))),
        serviceworker: serviceworker_config && webpack(serviceworker_config)
    };
}
function try_require(specifier) {
    try {
        return require(specifier);
    }
    catch (err) {
        if (err.code === 'MODULE_NOT_FOUND')
            return null;
        throw err;
    }
}

function create_routes(_a) {
    var files = (_a === void 0 ? { files: glob.sync('**/*.*', { cwd: __chunk1_js.src(), nodir: true }) } : _a).files;
    var routes = files
        .map(function (file) {
        if (/(^|\/|\\)_/.test(file))
            return;
        if (/]\[/.test(file)) {
            throw new Error("Invalid route " + file + " \u2014 parameters must be separated");
        }
        var base = file.replace(/\.[^/.]+$/, '');
        var parts = base.split('/'); // glob output is always posix-style
        if (parts[parts.length - 1] === 'index')
            parts.pop();
        var id = (parts.join('_').replace(/[[\]]/g, '$').replace(/^\d/, '_$&').replace(/[^a-zA-Z0-9_$]/g, '_')) || '_';
        var params = [];
        var param_pattern = /\[([^\]]+)\]/g;
        var match;
        while (match = param_pattern.exec(base)) {
            params.push(match[1]);
        }
        // TODO can we do all this with sub-parts? or does
        // nesting make that impossible?
        var pattern_string = '';
        var i = parts.length;
        var nested = true;
        while (i--) {
            var part = encodeURIComponent(parts[i].normalize()).replace(/%5B/g, '[').replace(/%5D/g, ']');
            var dynamic = ~part.indexOf('[');
            if (dynamic) {
                var matcher = part.replace(param_pattern, "([^/]+?)");
                pattern_string = nested ? "(?:\\/" + matcher + pattern_string + ")?" : "\\/" + matcher + pattern_string;
            }
            else {
                nested = false;
                pattern_string = "\\/" + part + pattern_string;
            }
        }
        var pattern = new RegExp("^" + pattern_string + "\\/?$");
        var test = function (url) { return pattern.test(url); };
        var exec = function (url) {
            var match = pattern.exec(url);
            if (!match)
                return;
            var result = {};
            params.forEach(function (param, i) {
                result[param] = match[i + 1];
            });
            return result;
        };
        return {
            id: id,
            type: path.extname(file) === '.html' ? 'page' : 'route',
            file: file,
            pattern: pattern,
            test: test,
            exec: exec,
            parts: parts,
            params: params
        };
    })
        .filter(Boolean)
        .sort(function (a, b) {
        if (a.file === '4xx.html' || a.file === '5xx.html')
            return -1;
        if (b.file === '4xx.html' || b.file === '5xx.html')
            return 1;
        var max = Math.max(a.parts.length, b.parts.length);
        for (var i = 0; i < max; i += 1) {
            var a_part = a.parts[i];
            var b_part = b.parts[i];
            if (!a_part)
                return -1;
            if (!b_part)
                return 1;
            var a_sub_parts = get_sub_parts(a_part);
            var b_sub_parts = get_sub_parts(b_part);
            var max_1 = Math.max(a_sub_parts.length, b_sub_parts.length);
            for (var i_1 = 0; i_1 < max_1; i_1 += 1) {
                var a_sub_part = a_sub_parts[i_1];
                var b_sub_part = b_sub_parts[i_1];
                if (!a_sub_part)
                    return 1; // b is more specific, so goes first
                if (!b_sub_part)
                    return -1;
                if (a_sub_part.dynamic !== b_sub_part.dynamic) {
                    return a_sub_part.dynamic ? 1 : -1;
                }
                if (!a_sub_part.dynamic && a_sub_part.content !== b_sub_part.content) {
                    return b_sub_part.content.length - a_sub_part.content.length;
                }
            }
        }
        throw new Error("The " + a.file + " and " + b.file + " routes clash");
    });
    return routes;
}
function get_sub_parts(part) {
    return part.split(/[\[\]]/)
        .map(function (content, i) {
        if (!content)
            return null;
        return {
            content: content,
            dynamic: i % 2 === 1
        };
    })
        .filter(Boolean);
}

exports.create_app = create_app;
exports.create_serviceworker = create_serviceworker;
exports.create_compilers = create_compilers;
exports.create_routes = create_routes;
//# sourceMappingURL=./core.ts.js.map
